# Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of the License "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description:
# Function Like Makefile (FLM) to create a resource header (.rsg)
# and resource files (.rsc, .r01, .r02 etc.)
#
#

## Parameters that are expected:
# TARGET
# TARGETPATH
# LANGUAGES
# HEADER
# HEADERONLY
# EPOCROOT
# MMPDEFS
# PRODUCT_INCLUDE
# SYSTEMINCLUDE
# USERINCLUDE
# GNUCPP
# GNUSED
# RCOMP
# OUTPUTPATH
# SOURCE
# BINCOPYDIRS


# The rss is pre-processed once for each language and results
# in a file with extension r$(LANGUAGE) where $(LANGUAGE) is
# either "sc" or a 2 (or more) digit number.
ifneq ($(TARGETPATH),)
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data/z/$(TARGETPATH))
else
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data)
endif
RESBASE:=$(RSCDIR)/$(TARGET_lower)

# Ensure that RELEASABLES and CLEANTARGETS cannot expand indefinitely in successive calls to this flm:
CLEANTARGETS:=
RELEASABLES:=
CREATABLEPATHS:=

# There is only one resource header (.rsg) file and we only
# make that if we are asked.
RSGDIR:=$(EPOCROOT)/epoc32/include
# If there are multiple LANGUAGES then it is the last one in the list
# which produces the header.
HEADLANG:=$(lastword $(LANGUAGES:SC=sc))
ifneq ($(or $(HEADER),$(HEADERONLY)),)
        RESOURCEHEADER:=$(RSGDIR)/$(HEADER)

else
        RESOURCEHEADER:=
endif

# we create intermediate .rpp and .d files
INTERBASE_TMP:=$(OUTPUTPATH)/$(TARGET_lower)_$(notdir $(basename $(SOURCE)))

LANGUAGES:=$(LANGUAGES:SC=sc) # ensure that we don't ever have to worry about case consistency w.r.t languages or get confused into thinking that SC!=sc (which it is)


# common pre-processor options

# We really should be using -iquote with a recent cpp.  This is a note for when we do update:
#CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
# -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-iquote $(I) ) $(foreach J,$(SYSTEMINCLUDE),-I $(J) )

CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
 -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-I$(I) ) -I- $(foreach J,$(SYSTEMINCLUDE),-I$(J) )

CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCDIR) $(RSGDIR) $(OUTPUTPATH) 

# We intend to generate the resource in an intermediate location and copy to the targetpath to
# ensure that when the "same" resource is built into separare target paths, it doesn't have to be 
# completely recreated each time - just copied.
RSCCOPYDIRS:=$(RSCDIR)

# additional binary resource copies performed based on BINCOPYDIRS
ifneq ($(BINCOPYDIRS),)
        RSCCOPYDIRS:=$(RSCCOPYDIRS) $(subst //,/,$(patsubst %,%/$(if $(TARGETPATH),/z/$(TARGETPATH),),$(BINCOPYDIRS)))
endif
CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCCOPYDIRS)

################################################################################
# Correct dependency information when a header file can't be found.
# If the c preprocessor can't find a dependency it appears as it did in the #include statement
# e.g. "filename.mbg" or "filename.rsg" in the dependency file.
ifneq ($(NO_DEPEND_GENERATE),)
  # This version minimises the size of dependency files, to contain only .mbg and .rsg deps.
  # It allows resources to be built in the right order but doesn't impose the weight of
  # of full dependency information which can overwhelm make in large builds.
  # The strategy is filter lines which don't have .rsg or .mbg dependencies in them and
  # to sift each line to leave out non-relevant things like other header files, .hrh 
  # files etc.  In the end don't print anything at all if we did not find the target.

  define  DEPENDENCY_CORRECTOR
  { $(DEPCRUNCH) --extensions rsg,mbg --assume '$(EPOCROOT)/epoc32/include' ; } 
  endef
  
else
  # This can correct the dependencies by assuming that the file will be in epoc32\include as this is the default
  DEPENDENCY_CORRECTOR:=$(GNUSED)  -r 's% ([^ \/]+\.((rsg)|(mbg)))% $(EPOCROOT)\/epoc32\/include\/\1%ig' 
endif

###############################################################################

define resource.deps
# $1 is the name of the intermediate RESOURCEFILE that is to be produced
# $2 is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $3 is the name of the dependency file

    $(if $(FLMDEBUG),$$(info <debug>resource.deps: $1 LANG:$2 dep $3 </debug>))

    RESOURCE_DEPS:: $3
    
    # could  force deps to be generated always - debatable.
    # .PHONY: $3

    $3: $(SOURCE)
	$(call startrule,resourcedependencies,FORCESUCCESS) \
	$(GNUCPP) -DLANGUAGE_$(3) -DLANGUAGE_$(subst sc,SC,$2) $(call makemacrodef,-D,$(MMPDEFS))\
	$(CPPOPT) $(SOURCE) -M -MG -MT"$1" | \
	$$(DEPENDENCY_CORRECTOR) >$3 \
	$(call endrule,resourcedependencies)

    SOURCETARGET_$(call sanitise,$(SOURCE)): $3

    CLEANTARGETS:=$$(CLEANTARGETS) $3

endef

# $1 is the name of the intermediate RESOURCEFILE
# $2 is the LANGUAGE		(eg. sc or 01 or 02 ...)
# Uses $(RESOURCEHEADER),$(SOURCE),$(HEADLANG),$(MMPDEFS) apart from some tools
define resource.build
    $(if $(FLMDEBUG),$$(info <debug>resource.build: $1 LANG:$2 </debug>))

      DOHEADER:=
      ifeq ($(HEADLANG),$2)
        ifneq ($(RESOURCEHEADER),)
          RESOURCE:: $(RESOURCEHEADER)

          DOHEADER:=-h$(RESOURCEHEADER)
          # strictly speaking if $1 is made then the header file should be there too
          # but suppose someone adds a header statement to their MMP after doing a build?
          # so here we recreate the resource header if its missing even if the intermediate resource
          # has actually been built.  The problem is: what if the rpp file is not there (oops)? 
          # So this is not perfect but I think that the situation is failrly unlikely.
          # We can afford to put in an if statement for the rsg file - it's not a race condition because
          # $1 is done and the build engine guarantees that it's there so no resource header
          # can be attempted while we're trying to test.
          $(RESOURCEHEADER) : $1
	    $(call startrule,resourcecompile,FORCESUCCESS) \
	    if [ ! -f "$(RESOURCEHEADER)" ]; then $(RCOMP) -m045,046,047 -u -h$$@ -s$1.rpp; fi \
	    $(call endrule,resourcecompile)

          RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)
        endif

      else
        # Use the headlang resource (in primaryfile) as the dependency 
        # "leader" for this resource
        $1: $(PRIMARYFILE)
      endif


      RESOURCE:: $1

      $1: $(SOURCE)
	  $(call startrule,resourcecompile,FORCESUCCESS) \
	  $(GNUCPP)  -DLANGUAGE_$2 -DLANGUAGE_$(subst sc,SC,$(2)) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -o $1.rpp && \
	  $(RCOMP) -m045,046,047 -u $$(DOHEADER) -o$$@ -s$1.rpp \
	  $(call endrule,resourcecompile)

    SOURCETARGET_$(call sanitise,$(SOURCE)): $1
    CLEANTARGETS:=$$(CLEANTARGETS) $1 $1.rpp 
endef

###############################################################################
# $1 is the name of the intermediate RESOURCEFILE
# $2 is the target name (without path) of the final resource file
define resource.makecopies
  
  $(call copyresource,$1,$(sort $(addsuffix /$2,$(RSCCOPYDIRS))))
endef


###############################################################################
# $1 is the intermediate filename base (eg. /epoc32/build/xxx/b_)
# $2 is the LANGUAGE		(eg. sc or 01 or 02 ...)
define resource.headeronly
  ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
    # generate the resource header dependency files
    $(eval DEPENDFILENAME:=$1_$2.rsg.d)

    RESOURCE_DEPS:: $(DEPENDFILENAME)
        
    # could  force deps to be generated always - debatable.
    # .PHONY: $(DEPENDFILENAME)
   
    $(DEPENDFILENAME): $(SOURCE)
	$(call startrule,resource.headeronly.deps,FORCESUCCESS) \
	$(GNUCPP) -DLANGUAGE_$2 -DLANGUAGE_$(subst sc,SC,$2) $(call makemacrodef,-D,$(MMPDEFS))\
	$(CPPOPT) $(SOURCE) -M -MG -MT"$(RESOURCEHEADER)" | \
	$$(DEPENDENCY_CORRECTOR) > $$@ \
	$(call endrule,resource.headeronly.deps)
   
    SOURCETARGET_$(call sanitise,$(SOURCE)): $(DEPENDFILENAME)
   
    CLEANTARGETS:=$$(CLEANTARGETS) $(DEPENDFILENAME)
  else # generate the resource header

    RESOURCE:: $(RESOURCEHEADER)
    
    $(RESOURCEHEADER): $(SOURCE)
	$(call startrule,resourceheader,FORCESUCCESS) \
	$(GNUCPP)  -DLANGUAGE_$2 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
	$(CPPOPT) $(SOURCE) -o $1_$2.rsg.rpp && \
	$(RCOMP) -m045,046,047 -u -h$$@ -s$1_$2.rsg.rpp \
	$(call endrule,resourceheader)

    RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)
    # individual source file compilation
    
    SOURCETARGET_$(call sanitise,$(SOURCE)): $(RESOURCEHEADER)
    
    $(eval DEPENDFILE:=$(wildcard $(DEPENDFILENAME)))
    
    ifneq "$(DEPENDFILE)" ""
      ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
         -include $(DEPENDFILE)
      endif
    endif
  endif
endef


###############################################################################
define copyresource
# $(1) is the source
# $(2) is the space separated list of destinations which must be filenames

   RELEASABLES:=$$(RELEASABLES) $(2)

   $(info <finalcopy source='$1'>$2</finalcopy>)
 
endef # copyresource #

###############################################################################
## call the generator

# We always create at least the header
# even if we sometimes don't create the resources
# The one on which the others will depend i.e. they will 
# "sit in it's dependency slipstream" or in other words
# We only have to make one dependency file because all of
# the other languages will benefit from the dependency file
# belonging to this language.

ifeq ($(HEADERONLY),)  # If we're doing the full job, not only the header
  # the guard is based on the languages we're building so that 2 resource blocks can 
  # create different languages if so needed (no known reason for this but someone
  # could do it and in the past it would have worked).
  GUARD:=TARGET_$(call sanitise,$(INTERBASE_TMP))
  $(if $(FLMDEBUG),$(info <debug>resource.flm: $(GUARD)=$($(GUARD)) LANGUAGES:=$(LANGUAGES)</debug>))
  # don't repeat existing languages
  REMAINING_LANGUAGES:=$(filter-out $($(GUARD)),$(LANGUAGES))
  $(if $(FLMDEBUG),$(info <debug>resource.flm:  REMAINING_LANGUAGES=$(REMAINING_LANGUAGES)</debug>))
  ifneq ($(REMAINING_LANGUAGES),)
    $(GUARD):=$($(GUARD)) $(REMAINING_LANGUAGES)

    LANGUAGES:=$(REMAINING_LANGUAGES)

    PRIMARYFILE:=$(INTERBASE_TMP).r$(HEADLANG)
    DEPENDFILENAME:=$(INTERBASE_TMP).r$(HEADLANG).d
  $(if $(FLMDEBUG),$(info <debug>resource.flm:  in guard with primary file=$(PRIMARYFILE)</debug>))
  
    ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
      $(eval $(call resource.deps,$(INTERBASE_TMP).r$(HEADLANG),$(HEADLANG),$(DEPENDFILENAME)))
    else
        RESOURCE:: $(PRIMARYFILE)

        # Creating resources
        $(foreach L,$(LANGUAGES),$(eval $(call resource.build,$(INTERBASE_TMP).r$(L),$(L),$(TARGET_lower).r$(L))))


        DEPENDFILE:=$(wildcard $(DEPENDFILENAME))
        
        ifneq "$(DEPENDFILE)" ""
          ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
             -include $(DEPENDFILE)
          endif
        endif
    endif
  endif
  ifneq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
    # Whether or not we have generated this resource for some other start
    # resource block, check if there are any new copies to be made for
    # this variant. e.g. winscw requires that we make some extra copies.
    # We tried to copy after running rcomp itself but we still need these
    # targets for the sake of dependencies or, for example, if someone
    # merely adds a new copy when the resource is up-to-date
    $(foreach L,$(LANGUAGES),$(eval $(call resource.makecopies,$(INTERBASE_TMP).r$(L),$(TARGET_lower).r$(L))))
  endif
else
  # Only Generating the header
  #
  GUARD:=TARGET_$(call sanitise,$(INTERBASE_TMP))_rsg
  $(if $(FLMDEBUG),$(info <debug>resource.flm: Headeronly $(INTERBASE_TMP) $(TARGET_lower).rsg LANGUAGES:=$(LANGUAGES)</debug>))
  ifeq ($($(GUARD)),)
    $(GUARD):=1
  
      $(eval $(call resource.headeronly,$(INTERBASE_TMP),$(HEADLANG)))
      # The headeronly macro manages dependency including on it's own
  endif
endif

# generate a resource file for each language
# For sc we generate $(RESBASE).rsc and define LANGUAGE_SC and LANGUAGE_sc.


###############################################################################
## .rfi generation in support of the gccxml build
## Note that .rfi files are created from the dependency files generated from preprocessing resources to create .rpp files
ifneq ($(RFIFILE),)
  RESOURCE:: $(RFIFILE)
  RELEASABLES:=$(RELEASABLES) $(RFIFILE)
  CREATABLEPATHS:=$(CREATABLEPATHS) $(dir $(RFIFILE))/

  RPPFILES:=$(foreach L,$(LANGUAGES:SC=sc),$(INTERBASE_TMP).r$(L).rpp)
  $(eval $(call generaterfifile,$(RFIFILE),$(RPPFILES),$(PRIMARYRPPFILE).d))
endif


## Clean up
$(call raptor_clean,$(CLEANTARGETS))
# make the output directories while reading makefile - some build engines prefer this
$(call makepath,$(CREATABLEPATHS))

# for the --what option and the log file
$(call raptor_release,$(RELEASABLES),RESOURCE)

