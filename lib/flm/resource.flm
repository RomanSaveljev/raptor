# Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of the License "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description:
# Function Like Makefile (FLM) to create a resource header (.rsg)
# and resource files (.rsc, .r01, .r02 etc.)
#
#

## Parameters that are expected:
# TARGET
# TARGETPATH
# LANGUAGES
# HEADER
# HEADERONLY
# EPOCROOT
# MMPDEFS
# PRODUCT_INCLUDE
# SYSTEMINCLUDE
# USERINCLUDE
# GNUCPP
# GNUSED
# RCOMP
# OUTPUTPATH
# SOURCE
# BINCOPYDIRS


# The rss is pre-processed once for each language and results
# in a file with extension r$(LANGUAGE) where $(LANGUAGE) is
# either "sc" or a 2 (or more) digit number.
ifneq ($(TARGETPATH),)
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data/z/$(TARGETPATH))
else
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data)
endif
RESBASE:=$(RSCDIR)/$(TARGET_lower)

# Ensure that RELEASABLES and CLEANTARGETS cannot expand indefinitely in successive calls to this flm:
CLEANTARGETS:=
RELEASABLES:=
CREATABLEPATHS:=

# There is only one resource header (.rsg) file and we only
# make that if we are asked.
RSGDIR:=$(EPOCROOT)/epoc32/include
# If there are multiple LANGUAGES then it is the last one in the list
# which produces the header.
HEADLANG:=$(lastword $(LANGUAGES:SC=sc))
ifneq ($(or $(HEADER),$(HEADERONLY)),)
        RESOURCEHEADER:=$(RSGDIR)/$(HEADER)

else
        RESOURCEHEADER:=
endif

# we create intermediate .rpp and .d files
INTERBASE_TMP:=$(OUTPUTPATH)/$(TARGET_lower)_$(notdir $(basename $(SOURCE)))
INTERBASE:=$(OUTPUTPATH)/$(TARGET_lower)


# common pre-processor options

# We really should be using -iquote with a recent cpp.  This is a note for when we do update:
#CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
# -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-iquote $(I) ) $(foreach J,$(SYSTEMINCLUDE),-I $(J) )

CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
 -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-I$(I) ) -I- $(foreach J,$(SYSTEMINCLUDE),-I$(J) )

CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCDIR) $(RSGDIR) $(OUTPUTPATH) 

# We intend to generate the resource in an intermediate location and copy to the targetpath to
# ensure that when the "same" resource is built into separare target paths, it doesn't have to be 
# completely recreated each time - just copied.
RSCCOPYDIRS:=$(RSCDIR)

# additional binary resource copies performed based on BINCOPYDIRS
ifneq ($(BINCOPYDIRS),)
        RSCCOPYDIRS:=$(RSCCOPYDIRS) $(subst //,/,$(patsubst %,%/$(if $(TARGETPATH),/z/$(TARGETPATH),),$(BINCOPYDIRS)))
endif
CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCCOPYDIRS)

###############################################################################


define resource.deps
# $(1) is the name of the intermediate RESOURCEFILE or HEADERFILE that is to be produced
# $(2) is the RPPFILE		(eg. /epoc32/build/xxx/b_sc.rpp)
# $(3) is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $(4) is the "primary" language on which all the others depend

    $(if $(FLMDEBUG),$$(info <debug>buildresourcedeps: $(1) for $(2) LANG:$(3) dep $(4) $5</debug>))


    # Correct dependency information when a header file can't be found.
    # If the c preprocessor can't find a dependency it appears as it did in the #include statement
    # e.g. "filename.mbg" or "filename.rsg" in the dependency file.

    ifneq ($(NO_DEPEND_GENERATE),)
      # This version minimises the size of dependency files, to contain only .mbg and .rsg deps.
      # It allows resources to be built in the right order but doesn't impose the weight of
      # of full dependency information which can overwhelm make in large builds.
      # The strategy is filter lines which don't have .rsg or .mbg dependencies in them and
      # to sift each line to leave out non-relevant things like other header files, .hrh 
      # files etc.  In the end don't print anything at all if we did not find the target.

      define  DEPENDENCY_CORRECTOR
      { $(DEPCRUNCH) --extensions rsg,mbg --assume '$$$$(EPOCROOT)/epoc32/include' ; } 
      endef
      
    else
      # This can correct the dependencies by assuming that the file will be in epoc32\include as this is the default
      DEPENDENCY_CORRECTOR:=$(GNUSED)  -r 's% ([^ \/]+\.((rsg)|(mbg)))% $(EPOCROOT)\/epoc32\/include\/\1%ig' 
    endif


    ifeq "$1" "$4"
        RESOURCE_DEPS:: $4.d
        
        # could  force deps to be generated always - debatable.
        # .PHONY: $4.d 

        $4.d: $(SOURCE)
	     $(call startrule,resourcedependencies,FORCESUCCESS) \
	     $(GNUCPP) -DLANGUAGE_$(3) -DLANGUAGE_$(subst sc,SC,$3) $(call makemacrodef,-D,$(MMPDEFS))\
	     $(CPPOPT) $(SOURCE) -M -MG -MT"$1" | \
	     $$(DEPENDENCY_CORRECTOR) >$4.d \
	     $(call endrule,resourcedependencies)

        SOURCETARGET_$(call sanitise,$(SOURCE)): $4.d

    endif
endef

# $(1) is the name of the intermediate RESOURCEFILE
# $(2) is the RPPFILE		(eg. /epoc32/build/xxx/b_sc.rpp)
# $(3) is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $(4) is the "primary" language on which all the others depend
# $(5) is the target name (without path) of the final resource file
define resource.build
    $(if $(FLMDEBUG),$$(info <debug>buildresource: $(1) for $(2) LANG:$(3) dep $(4)</debug>))

      $(eval DOHEADER:=)
      ifeq ($(HEADLANG),$3)
        ifneq ($(RESOURCEHEADER),)
          $(eval DOHEADER:=-h$(RESOURCEHEADER))
          RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)

          # In an odd situation, one MMP can generate a resource and the other can generate the header
          # for it.  In these circumstances one may need to generate the header file even if the resource
          # is already there.  This rule makes it possible.  It's undesirably complicated but does
          # deal with a situation that can happen in incremental builds.
          $(RESOURCEHEADER): $1
	    $(call startrule,resourceheader,FORCESUCCESS) \
	    if [ ! -e "$(RESOURCEHEADER)" ]; then  \
	      $(GNUCPP) -C -DLANGUAGE_$3 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
	      $(CPPOPT) $(SOURCE) -o $2 && \
	      $(RCOMP) -m045,046,047 -u $(DOHEADER) -s$2 ; \
	    fi \
	    $(call endrule,resourceheader)
	endif
      endif

      RESOURCE:: $1

      $1: $(SOURCE)
	  $(call startrule,resourcecompile,FORCESUCCESS) \
	  $(GNUCPP) -C -DLANGUAGE_$3 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -o $2 && \
	  $(RCOMP) -m045,046,047 -u $(DOHEADER) -o$$@ -s$2 \
	  $(call endrule,resourcecompile)

      SOURCETARGET_$(call sanitise,$(SOURCE)): $1
    CLEANTARGETS:=$$(CLEANTARGETS) $1 $2 $(RESOURCEHEADER)

    ifeq "$1" "$4"
      $(eval DEPENDFILENAME:=$1.d)
      $(eval DEPENDFILE:=$(wildcard $(DEPENDFILENAME)))
      
      CLEANTARGETS:=$$(CLEANTARGETS) $(DEPENDFILENAME)
      ifneq "$(DEPENDFILE)" ""
        ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
           -include $(DEPENDFILE)
        endif
      endif
    else
         $1 : $4
    endif
endef


# $(1) is the name of the RESOURCEHEADER
# $(2) is the RPPFILE		(eg. /epoc32/build/xxx/b_sc.rpp)
# $(3) is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $(5) is the target name (without path) of the final resource file
define resource.headeronly
      RESOURCE:: $(RESOURCEHEADER)

      $(RESOURCEHEADER): $(SOURCE)
	  $(call startrule,resourceheader,FORCESUCCESS) \
	  $(GNUCPP) -C -DLANGUAGE_$3 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -o $2 && \
	  $(RCOMP) -m045,046,047 -u -h$$@ -s$2 \
	  $(call endrule,resourceheader)

      RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)
      # individual source file compilation

      SOURCETARGET_$(call sanitise,$(SOURCE)): $(RESOURCEHEADER)

      CLEANTARGETS:=$$(CLEANTARGETS) $(RESOURCEHEADER)


      $(eval DEPENDFILENAME:=$1.d)
      $(eval DEPENDFILE:=$(wildcard $(DEPENDFILENAME)))
      
      CLEANTARGETS:=$$(CLEANTARGETS) $(DEPENDFILENAME)
      ifneq "$(DEPENDFILE)" ""
        ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
           -include $(DEPENDFILE)
        endif
      endif
endef



  endif

  # Whether or not we have generated this resource for some other variant, check if there
  # are any new copies to be made for this variant. e.g. winscw requires that we make
  # some extra copies.  We tried to copy after running rcomp itself but we still need these
  # targets for the sake of dependencies or, for example, if someone merely adds a new copy 
  # when the resource is up-to-date
  
  $(call copyresource,$1,$(sort $(patsubst %,%/$5,$(RSCCOPYDIRS))))

endef # buildresource #

###############################################################################
define copyresource
# $(1) is the source
# $(2) is the space separated list of destinations which must be filenames

   RELEASABLES:=$$(RELEASABLES) $(2)

   $(info <finalcopy source='$1'>$2</finalcopy>)
 
endef # copyresource #

###############################################################################
## call the generator

# We always create at least the header
# even if we sometimes don't create the resources
# The one on which the others will depend i.e. they will 
# "sit in it's dependency slipstream" or in other words
# We only have to make one dependency file because all of
# the other languages will benefit from the dependency file
# belonging to this language.
ifeq ($(HEADERONLY),)
  ifeq ($(TARGET_$(call sanitise,$INTERBASE_TMP)),)
    TARGET_$(call sanitise,$INTERBASE_TMP):=1

    PRIMARYFILE:=$(INTERBASE_TMP).r$(HEADLANG)
    RESOURCE:: $(PRIMARYFILE)
  
    ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
      $(foreach L,$(LANGUAGES:SC=sc),$(eval $(call resource.deps,$(INTERBASE_TMP).r$(L),$(INTERBASE_TMP)_$(L).rpp,$(L),$(PRIMARYFILE))))
    else
      ifeq ($(TARGET_$(call sanitise,$INTERBASE_TMP)),)
        TARGET_$(call sanitise,$INTERBASE_TMP):=1
        $(foreach L,$(LANGUAGES:SC=sc),$(eval $(call resource.build,$(INTERBASE_TMP).r$(L),$(INTERBASE_TMP)_$(L).rpp,$(L),$(PRIMARYFILE),$(notdir $(INTERBASE).r$(L)))))
      endif
    endif
  
  else
    INTERBASE_TMP:=$(INTERBASE_TMP)_h 
    ifeq ($(TARGET_$(call sanitise,$INTERBASE_TMP)),)
      TARGET_$(call sanitise,$INTERBASE_TMP):=1
  
      RESOURCE:: $$(RESOURCEHEADER)
      PRIMARYFILE:=$(RESOURCEHEADER)
      ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
        $(eval $(call resource.deps,$(INTERBASE_TMP).r$(HEADLANG),$(INTERBASE_TMP)_$(HEADLANG).rpp,$(HEADLANG),$(PRIMARYFILE)))
      else
        $(eval $(call resource.headeronly,$(INTERBASE_TMP).r$(HEADLANG),$(INTERBASE_TMP)_$(HEADLANG).rpp,$(HEADLANG),$(PRIMARYFILE),$(notdir $(INTERBASE).r$(HEADLANG))))
      endif
  endif
endif

# generate a resource file for each language
# For sc we generate $(RESBASE).rsc and define LANGUAGE_SC and LANGUAGE_sc.


###############################################################################
## .rfi generation in support of the gccxml build
## Note that .rfi files are created from the dependency files generated from preprocessing resources to create .rpp files
ifneq ($(RFIFILE),)
  RESOURCE:: $(RFIFILE)
  RELEASABLES:=$(RELEASABLES) $(RFIFILE)
  CREATABLEPATHS:=$(CREATABLEPATHS) $(dir $(RFIFILE))/

  RPPFILES:=$(foreach L,$(LANGUAGES:SC=sc),$(INTERBASE_TMP)_$(L).rpp)
  $(eval $(call generaterfifile,$(RFIFILE),$(RPPFILES),$(PRIMARYRPPFILE).d))
endif


## Clean up
$(call raptor_clean,$(CLEANTARGETS))
# make the output directories while reading makefile - some build engines prefer this
$(call makepath,$(CREATABLEPATHS))

# for the --what option and the log file
RELEASABLES:=$(RELEASABLES) $(DESTRPP) $(INFOFILE)
$(call raptor_release,$(RELEASABLES),RESOURCE)

