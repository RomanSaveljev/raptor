# Copyright (c) 2007-2010 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of the License "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description:
# Function Like Makefile (FLM) to create a resource header (.rsg)
# and resource files (.rsc, .r01, .r02 etc.)
#
#

## Parameters that are expected:
# TARGET
# TARGETPATH
# LANGUAGES
# HEADER
# HEADERONLY
# EPOCROOT
# MMPDEFS
# PRODUCT_INCLUDE
# SYSTEMINCLUDE
# USERINCLUDE
# GNUCPP
# GNUSED
# RCOMP
# OUTPUTPATH
# SOURCE
# BINCOPYDIRS


# The rss is pre-processed once for each language and results
# in a file with extension r$(LANGUAGE) where $(LANGUAGE) is
# either "sc" or a 2 (or more) digit number.
ifneq ($(TARGETPATH),)
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data/z/$(TARGETPATH))
else
RSCDIR:=$(subst //,/,$(EPOCROOT)/epoc32/data)
endif
RESBASE:=$(RSCDIR)/$(TARGET_lower)

# Ensure that RELEASABLES and CLEANTARGETS cannot expand indefinitely in successive calls to this flm:
CLEANTARGETS:=
RELEASABLES:=
CREATABLEPATHS:=

# There is only one resource header (.rsg) file and we only
# make that if we are asked.
RSGDIR:=$(EPOCROOT)/epoc32/include
# If there are multiple LANGUAGES then it is the last one in the list
# which produces the header.
HEADLANG:=$(lastword $(LANGUAGES:SC=sc))
ifneq ($(or $(HEADER),$(HEADERONLY)),)
        RESOURCEHEADER:=$(RSGDIR)/$(HEADER)

else
        RESOURCEHEADER:=
endif

# we create intermediate .rpp and .d files
INTERBASE_TMP:=$(OUTPUTPATH)/$(TARGET_lower)_$(notdir $(basename $(SOURCE)))


# common pre-processor options

# We really should be using -iquote with a recent cpp.  This is a note for when we do update:
#CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
# -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-iquote $(I) ) $(foreach J,$(SYSTEMINCLUDE),-I $(J) )

CPPOPT:=-nostdinc -undef -Wno-trigraphs -D_UNICODE -include $(PRODUCT_INCLUDE)\
 -I$(dir $(SOURCE)) $(foreach I, $(USERINCLUDE),-I$(I) ) -I- $(foreach J,$(SYSTEMINCLUDE),-I$(J) )

CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCDIR) $(RSGDIR) $(OUTPUTPATH) 

# We intend to generate the resource in an intermediate location and copy to the targetpath to
# ensure that when the "same" resource is built into separare target paths, it doesn't have to be 
# completely recreated each time - just copied.
RSCCOPYDIRS:=$(RSCDIR)

# additional binary resource copies performed based on BINCOPYDIRS
ifneq ($(BINCOPYDIRS),)
        RSCCOPYDIRS:=$(RSCCOPYDIRS) $(subst //,/,$(patsubst %,%/$(if $(TARGETPATH),/z/$(TARGETPATH),),$(BINCOPYDIRS)))
endif
CREATABLEPATHS:=$(CREATABLEPATHS) $(RSCCOPYDIRS)

################################################################################
# Correct dependency information when a header file can't be found.
# If the c preprocessor can't find a dependency it appears as it did in the #include statement
# e.g. "filename.mbg" or "filename.rsg" in the dependency file.
ifneq ($(NO_DEPEND_GENERATE),)
  # This version minimises the size of dependency files, to contain only .mbg and .rsg deps.
  # It allows resources to be built in the right order but doesn't impose the weight of
  # of full dependency information which can overwhelm make in large builds.
  # The strategy is filter lines which don't have .rsg or .mbg dependencies in them and
  # to sift each line to leave out non-relevant things like other header files, .hrh 
  # files etc.  In the end don't print anything at all if we did not find the target.

  define  DEPENDENCY_CORRECTOR
  { $(DEPCRUNCH) --extensions rsg,mbg --assume '$(EPOCROOT)/epoc32/include' ; } 
  endef
  
else
  # This can correct the dependencies by assuming that the file will be in epoc32\include as this is the default
  DEPENDENCY_CORRECTOR:=$(GNUSED)  -r 's% ([^ \/]+\.((rsg)|(mbg)))% $(EPOCROOT)\/epoc32\/include\/\1%ig' 
endif

###############################################################################

define resource.deps
# $1 is the name of the intermediate RESOURCEFILE that is to be produced
# $2 is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $3 is the name of the dependency file

    $(if $(FLMDEBUG),$$(info <debug>resource.deps: $1 LANG:$2 dep $3 </debug>))

    RESOURCE_DEPS:: $3
    
    # could  force deps to be generated always - debatable.
    # .PHONY: $3

    $3: $(SOURCE)
	$(call startrule,resourcedependencies,FORCESUCCESS) \
	$(GNUCPP) -DLANGUAGE_$(3) -DLANGUAGE_$(subst sc,SC,$2) $(call makemacrodef,-D,$(MMPDEFS))\
	$(CPPOPT) $(SOURCE) -M -MG -MT"$1" | \
	$$(DEPENDENCY_CORRECTOR) >$3 \
	$(call endrule,resourcedependencies)

    SOURCETARGET_$(call sanitise,$(SOURCE)): $3

    CLEANTARGETS:=$$(CLEANTARGETS) $3

endef

# $1 is the name of the intermediate RESOURCEFILE
# $2 is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $3 is the target name (without path) of the final resource file
# Uses $(RESOURCEHEADER),$(SOURCE),$(HEADLANG),$(MMPDEFS) apart from some tools
define resource.build
    $(if $(FLMDEBUG),$$(info <debug>resource.build: $1 LANG:$2 for $3</debug>))

      $(eval DOHEADER:=)
      ifeq ($(HEADLANG),$2)
        ifneq ($(RESOURCEHEADER),)
          $(eval DOHEADER:=-h$(RESOURCEHEADER))
          $(RESOURCEHEADER) : $1
          RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)
        endif
      else
        #nothing
      endif

      RESOURCE:: $1

      $1: $(SOURCE)
	  $(call startrule,resourcecompile,FORCESUCCESS) \
	  $(GNUCPP) -C -DLANGUAGE_$2 -DLANGUAGE_$(subst sc,SC,$(2)) $(call makemacrodef,-D,$(MMPDEFS))\
	  $(CPPOPT) $(SOURCE) -o $1.rpp && \
	  $(RCOMP) -m045,046,047 -u $(DOHEADER) -o$$@ -s$1.rpp \
	  $(call endrule,resourcecompile)

    SOURCETARGET_$(call sanitise,$(SOURCE)): $1
    CLEANTARGETS:=$$(CLEANTARGETS) $1 $1.rpp $(RESOURCEHEADER)

  # Whether or not we have generated this resource for some other variant, check if there
  # are any new copies to be made for this variant. e.g. winscw requires that we make
  # some extra copies.  We tried to copy after running rcomp itself but we still need these
  # targets for the sake of dependencies or, for example, if someone merely adds a new copy 
  # when the resource is up-to-date
  
  $(call copyresource,$1,$(sort $(addsuffix /$3,$(RSCCOPYDIRS))))

endef


# $1 is the name of the RESOURCEHEADER
# $2 is the intermediate filename base (eg. /epoc32/build/xxx/b_)
# $3 is the LANGUAGE		(eg. sc or 01 or 02 ...)
# $4 is the target name (without path) of the final resource file
define resource.headeronly
  ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
    # generate the resource header dependency files
    $(eval DEPENDFILENAME:=$2_$3_h.d)

    RESOURCE_DEPS:: $(DEPENDFILENAME)
        
    # could  force deps to be generated always - debatable.
    # .PHONY: $(DEPENDFILENAME)
   
    $(DEPENDFILENAME): $(SOURCE)
        $(call startrule,resource.headeronly.deps,FORCESUCCESS) \
        $(GNUCPP) -DLANGUAGE_$(3) -DLANGUAGE_$(subst sc,SC,$3) $(call makemacrodef,-D,$(MMPDEFS))\
        $(CPPOPT) $(SOURCE) -M -MG -MT"$1" | \
        $$(DEPENDENCY_CORRECTOR) > $$@ \
        $(call endrule,resource.headeronly.deps)
   
    SOURCETARGET_$(call sanitise,$(SOURCE)): $(DEPENDFILENAME)
   
  else # generate the resource header

    RESOURCE:: $(RESOURCEHEADER)
    
    $(RESOURCEHEADER): $(SOURCE)
      $(call startrule,resourceheader,FORCESUCCESS) \
      $(GNUCPP) -C -DLANGUAGE_$3 -DLANGUAGE_$(subst sc,SC,$(3)) $(call makemacrodef,-D,$(MMPDEFS))\
      $(CPPOPT) $(SOURCE) -o $2_$3_h.rpp && \
      $(RCOMP) -m045,046,047 -u -h$$@ -s$2_$3_h.rpp \
      $(call endrule,resourceheader)

    RELEASABLES:=$$(RELEASABLES) $(RESOURCEHEADER)
    # individual source file compilation
    
    SOURCETARGET_$(call sanitise,$(SOURCE)): $(RESOURCEHEADER)
    
    CLEANTARGETS:=$$(CLEANTARGETS) $(RESOURCEHEADER)

    $(eval DEPENDFILE:=$(wildcard $(DEPENDFILENAME)))
    
    CLEANTARGETS:=$$(CLEANTARGETS) $(DEPENDFILENAME)
    ifneq "$(DEPENDFILE)" ""
      ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
         -include $(DEPENDFILE)
      endif
    endif
  endif
endef


###############################################################################
define copyresource
# $(1) is the source
# $(2) is the space separated list of destinations which must be filenames

   RELEASABLES:=$$(RELEASABLES) $(2)

   $(info <finalcopy source='$1'>$2</finalcopy>)
 
endef # copyresource #

###############################################################################
## call the generator

# We always create at least the header
# even if we sometimes don't create the resources
# The one on which the others will depend i.e. they will 
# "sit in it's dependency slipstream" or in other words
# We only have to make one dependency file because all of
# the other languages will benefit from the dependency file
# belonging to this language.

ifeq ($(HEADERONLY),)  # If we're doing the full job, not only the header
  GUARD:=TARGET_$(call sanitise,$(INTERBASE_TMP))
  $(if $(FLMDEBUG),$(info <debug>resource.flm: INTERBASE_TMP=$(INTERBASE_TMP) $(GUARD)=$($(GUARD))</debug>))
  ifeq ($($(GUARD)),)
    $(GUARD):=1

    PRIMARYFILE:=$(INTERBASE_TMP).r$(HEADLANG)
    DEPENDFILENAME:=$(INTERBASE_TMP)_$(HEADLANG).d
    RESOURCE:: $(PRIMARYFILE)
  
    ifeq "$(MAKEFILE_GROUP)" "RESOURCE_DEPS"
      $(eval $(call resource.deps,$(INTERBASE_TMP).r$(HEADLANG),$(HEADLANG),$(DEPENDFILENAME)))
    else
        # Creating resources
        $(foreach L,$(LANGUAGES:SC=sc),$(eval $(call resource.build,$(INTERBASE_TMP).r$(L),$(L),$(TARGET_lower).r$(L))))


        DEPENDFILE:=$(wildcard $(DEPENDFILENAME))
        
        ifneq "$(DEPENDFILE)" ""
          ifeq "$(filter %CLEAN,$(call uppercase,$(MAKECMDGOALS)))" ""
             -include $(DEPENDFILE)
          endif
        endif
    endif
  endif
else
  # Only Generating the header
  #
  INTERBASE_TMP:=$(INTERBASE_TMP)_h 
  GUARD:=TARGET_$(call sanitise,$(INTERBASE_TMP))
  ifeq ($($(GUARD)),)
    $(GUARD):=1
  
    RESOURCE:: $(RESOURCEHEADER)
    PRIMARYFILE:=$(RESOURCEHEADER)

      $(eval $(call resource.headeronly,$(INTERBASE_TMP).r$(HEADLANG),$(INTERBASE_TMP)_$(HEADLANG).rpp,$(HEADLANG),$(RESOURCEHEADER),$(TARGET_lower).r$(HEADLANG)))
      # The headeronly macro manages dependency including on it's own
  endif
endif

# generate a resource file for each language
# For sc we generate $(RESBASE).rsc and define LANGUAGE_SC and LANGUAGE_sc.


###############################################################################
## .rfi generation in support of the gccxml build
## Note that .rfi files are created from the dependency files generated from preprocessing resources to create .rpp files
ifneq ($(RFIFILE),)
  RESOURCE:: $(RFIFILE)
  RELEASABLES:=$(RELEASABLES) $(RFIFILE)
  CREATABLEPATHS:=$(CREATABLEPATHS) $(dir $(RFIFILE))/

  RPPFILES:=$(foreach L,$(LANGUAGES:SC=sc),$(INTERBASE_TMP)_$(L).rpp)
  $(eval $(call generaterfifile,$(RFIFILE),$(RPPFILES),$(PRIMARYRPPFILE).d))
endif


## Clean up
$(call raptor_clean,$(CLEANTARGETS))
# make the output directories while reading makefile - some build engines prefer this
$(call makepath,$(CREATABLEPATHS))

# for the --what option and the log file
RELEASABLES:=$(RELEASABLES) $(DESTRPP) $(INFOFILE)
$(call raptor_release,$(RELEASABLES),RESOURCE)

